/*
 * Copyright (c) 2013 Omkar Kanase
 *
 * This software is provided 'as-is', without any express or implied
 * warranty.  In no event will the authors be held liable for any damages
 * arising from the use of this software.
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 * 1. The origin of this software must not be misrepresented; you must not
 * claim that you wrote the original software. If you use this software
 * in a product, an acknowledgment in the product documentation would be
 * appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 * misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 */

#include "stdafx.h"
#include <string>
#include <sstream>

using namespace std;

void WriteSignal0Base(FILE* file)
{
	fprintf(file,
		"/*\n"
		" * Copyright (c) 2013 Omkar Kanase\n"
		" *\n"
		" * This software is provided 'as-is', without any express or implied\n"
		" * warranty.  In no event will the authors be held liable for any damages\n"
		" * arising from the use of this software.\n"
		" * Permission is granted to anyone to use this software for any purpose,\n"
		" * including commercial applications, and to alter it and redistribute it\n"
		" * freely, subject to the following restrictions:\n"
		" * 1. The origin of this software must not be misrepresented; you must not\n"
		" * claim that you wrote the original software. If you use this software\n"
		" * in a product, an acknowledgment in the product documentation would be\n"
		" * appreciated but is not required.\n"
		" * 2. Altered source versions must be plainly marked as such, and must not be\n"
		" * misrepresented as being the original software.\n"
		" * 3. This notice may not be removed or altered from any source distribution.\n"
		" */\n"
		"\n"
		"// for 0 args\n"
		"/**\n"
		" * Base class for all signals.\n"
		" */\n"
		"class BaseSignal\n"
		"{\n"
		"public:\n"
		"\t/**\n"
		"\t * Derived class implements this to disconnect connected slots to this signal.\n"
		"\t * \\param ptr Pointer to the slot to disconnect.\n"
		"\t */\n"
		"\tvirtual void DisconnectSlot(void* ptr){};\n"
		"};\n"
		"\n"
		"/**\n"
		" *\tAll derived classes from this one are disconnected automatically on destruction of that class.\n"
		" */\n"
		"class BaseSlot\n"
		"{\n"
		"public:\n"
		"\tvector<BaseSignal*> Signals; ///< Pointers to signals connected to this object.\n"
		"\n"
		"public:\n"
		"\tvirtual ~BaseSlot(); ///< Virtual destructor deletes all signals connected to this object.\n"
		"\n"
		"\t/**\n"
		"\t * Disconnects specified signal and deletes it from this list if it exists.\n"
		"\t * \\param ptr Pointer to the signal to be disconnected.\n"
		"\t */\n"
		"\tvirtual void DisconnectSignal(BaseSignal* ptr);\n"
		"};\n"
		"\n"
		"/**\n"
		" * Used to invoke provided function from class.\n"
		" * \\tparam ret Return data type.\n"
		" * \\tparam cls Class name.\n"
		" * \\tparam fn Function pointer.\n"
		" */\n"
		"template<class cls, class ret, ret (cls::*fn)()>\n"
		"class Invoker0\n"
		"{\n"
		"public:\n"
		"\t/**\n"
		"\t * Invokes specified function.\n"
		"\t * \\param ptr Pointer to the class object used to invoke this function.\n"
		"\t * \\return Returns provided data type value.\n"
		"\t */\n"
		"\tstatic ret Invoke(void* ptr)\n"
		"\t{\n"
		"\t\treturn (static_cast<cls*>(ptr)->*fn)();\n"
		"\t}\n"
		"};\n"
		"\n"
		"/**\n"
		" * Used to invoke global function.\n"
		" * \\tparam ret Return data type.\n"
		" * \\tparam fn Function pointer.\n"
		" */\n"
		"template<class ret, ret (*fn)()>\n"
		"class Invoker0g\n"
		"{\n"
		"public:\n"
		"\t/**\n"
		"\t * Invokes specified function with specified arguments.\n"
		"\t * \\param ptr Not used its just for signature matching purpose.\n"
		"\t * \\return Returns provided data type value.\n"
		"\t */\n"
		"\tstatic ret Invoke(void* ptr)\n"
		"\t{\n"
		"\t\treturn (*fn)();\n"
		"\t}\n"
		"};\n"
		"\n"
		"/**\n"
		" * Signal to dynamically manage class/global function pointers.\n"
		" * \\tparam ret Return type of the functions which can be linked by this signal.\n"
		" */\n"
		"template<class ret = void>\n"
		"class BaseSignal0\n"
		"{\n"
		"public:\n"
		"\ttypedef ret (*inv) (void*); ///< Function type.\n"
		"\tinv f0;  ///< Function pointer to invoke linked function..\n"
		"\tvoid* p; ///< Pointer to the class object used to invoke specified class function.\n"
		"\tBaseSlot* s; ///<< Pointer to the base slot connected to this signal.\n"
		"\tBaseSignal* parent; ///< Parent signal class object used for auto disconnection of slots.\n"
		"\n"
		"public:\n"
		"\t/**\n"
		"\t * Default constructor.\n"
		"\t */\n"
		"\tBaseSignal0()\n"
		"\t{\n"
		"\t\tp = 0;\n"
		"\t\tf0 = 0;\n"
		"\t\ts = 0;\n"
		"\t\tparent = 0;\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Connects specified class and class function to this signal.\n"
		"\t * \\param ptr Pointer to the class object which is used to invoke specified function.\n"
		"\t * \\tparam cls Class name.\n"
		"\t * \\tparam fn Pointer to the class function.\n"
		"\t */\n"
		"\ttemplate<class cls, ret (cls::*fn)()>\n"
		"\tvoid Connect(cls* ptr)\n"
		"\t{\n"
		"\t\tf0 = &Invoker0<cls, ret, fn>::Invoke;\n"
		"\t\tp = ptr;\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Connects specified function with his signal.\n"
		"\t * \\tparam fn Pointer to the class function.\n"
		"\t */\n"
		"\ttemplate<ret (*fn)()>\n"
		"\tvoid Connect()\n"
		"\t{\n"
		"\t\tf0 = &Invoker0g<ret, fn>::Invoke;\n"
		"\t\tp = 0;\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Checks whether function pointer is null.\n"
		"\t * \\return true if function pointer is not null otherwise false.\n"
		"\t */\n"
		"\tbool Check()\n"
		"\t{\n"
		"\t\tif(f0==0) return false;\n"
		"\t\treturn true;\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Invokes function linked to this signal.\n"
		"\t * \\return Specified data type value.\n"
		"\t */\n"
		"\tret Invoke()\n"
		"\t{\n"
		"\t\treturn f0(p);\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Invokes function linked to this signal.\n"
		"\t * \\return Specified data type value.\n"
		"\t */\n"
		"\tret operator() ()\n"
		"\t{\n"
		"\t\treturn f0(p);\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Compares specified signal with this signal.\n"
		"\t * \\param val Pointer to the signal to compare with.\n"
		"\t * \\return true both are equal otherwise false.\n"
		"\t */\n"
		"\tbool operator==(BaseSignal0<ret>& val)\n"
		"\t{\n"
		"\t\tif(val.f0 == f0 && val.p == p) return true;\n"
		"\t\treturn false;\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Sets slot and adds parent signal to slot connections list.\n"
		"\t * \\param val Pointer to the slot to connect.\n"
		"\t */\n"
		"\tvoid SetSlot(BaseSlot* val)\n"
		"\t{\n"
		"\t\tthis->s = val;\n"
		"\t\tif(s != 0) s->Signals.push_back(parent);\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Copies specified signal to this one.\n"
		"\t * \\param val Pointer to the signal to copy.\n"
		"\t * \\return Reference to this signal.\n"
		"\t */\n"
		"\tBaseSignal0& operator=(BaseSignal0 const& val)\n"
		"\t{\n"
		"\t\tthis->f0 = val.f0;\n"
		"\t\tthis->p = val.p;\n"
		"\t\tthis->parent = val.parent;\n"
		"\t\tSetSlot(val.s);\n"
		"\t\treturn *this;\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Copies specified signal to this one.\n"
		"\t * \\param val Pointer to the signal to copy.\n"
		"\t */\n"
		"\tBaseSignal0(BaseSignal0 const& val)\n"
		"\t{\n"
		"\t\tthis->f0 = val.f0;\n"
		"\t\tthis->p = val.p;\n"
		"\t\tthis->parent = val.parent;\n"
		"\t\tSetSlot(val.s);\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Virtual destructor disconnects all signals from linked slot.\n"
		"\t */\n"
		"\tvirtual ~BaseSignal0()\n"
		"\t{\n"
		"\t\tif(s!=0) s->DisconnectSignal(parent);\n"
		"\t}\n"
		"};\n"
		"\n"
		"/**\n"
		" * Signal used for signaling of events to the specified functions.\n"
		" */\n"
		"class Signal0 : public BaseSignal\n"
		"{\n"
		"protected:\n"
		"\tvector<BaseSignal0< > > events; ///< Signals list.\n"
		"\tunsigned int i; ///< Used for iteration.\n"
		"\tunsigned int sz; ///< Used for iteration.\n"
		"\n"
		"public:\n"
		"\t/**\n"
		"\t * Connects specified not derived(inherited) class and class function to this signal.\n"
		"\t * \\param obj Pointer to the class object which is used to invoke specified function.\n"
		"\t * \\return Number of connections to this signal - 1.\n"
		"\t * \\tparam cls Class name.\n"
		"\t * \\tparam fn Pointer to the class function.\n"
		"\t */\n"
		"\ttemplate<class cls, void (cls::*fn)()>\n"
		"\tunsigned int RegisterSingleHandler(cls* obj)\n"
		"\t{\n"
		"\t\tBaseSignal0<> bs;\n"
		"\t\tbs.Connect<cls, fn>(obj);\n"
		"\t\tevents.push_back(bs);\n"
		"\t\treturn events.size() - 1;\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Connects specified derived(inherited) class and class function to this signal.\n"
		"\t * \\param obj Pointer to the class object which is used to invoke specified function.\n"
		"\t * \\return Number of connections to this signal - 1.\n"
		"\t * \\tparam cls Class name.\n"
		"\t * \\tparam fn Pointer to the class function.\n"
		"\t */\n"
		"\ttemplate<class cls, void (cls::*fn)()>\n"
		"\tunsigned int RegisterHandler(cls* obj)\n"
		"\t{\n"
		"\t\tBaseSignal0<> bs;\n"
		"\t\tbs.Connect<cls, fn>(obj);\n"
		"\t\tbs.parent = this;\n"
		"\t\tbs.SetSlot(dynamic_cast<BaseSlot*>(obj));\n"
		"\t\tevents.push_back(bs);\n"
		"\t\treturn events.size() - 1;\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Connects specified global function to this signal.\n"
		"\t * \\return Number of connections to this signal - 1.\n"
		"\t * \\tparam fn Pointer to the global function.\n"
		"\t */\n"
		"\ttemplate<void (*fn)()>\n"
		"\tunsigned int RegisterHandler()\n"
		"\t{\n"
		"\t\tBaseSignal0<> bs;\n"
		"\t\tbs.Connect<fn>();\n"
		"\t\tevents.push_back(bs);\n"
		"\t\treturn events.size() - 1;\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Disconnects specified class and class function from this signal.\n"
		"\t * \\param obj Pointer to the class object which is to be disconnected.\n"
		"\t * \\tparam cls Class name.\n"
		"\t * \\tparam fn Pointer to the class function.\n"
		"\t */\n"
		"\ttemplate<class cls, void (cls::*fn)()>\n"
		"\tvoid DisconnectHandler(cls* obj)\n"
		"\t{\n"
		"\t\tBaseSignal0<> bs;\n"
		"\t\tbs.Connect<cls, fn>(obj);\n"
		"\t\tsz = events.size();\n"
		"\t\tfor(i = 0; i<sz; i++)\n"
		"\t\t{\n"
		"\t\t\tif(events[i]==bs)\n"
		"\t\t\t{\n"
		"\t\t\t\tDisconnectHandler(i);\n"
		"\t\t\t\treturn;\n"
		"\t\t\t}\n"
		"\t\t}\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Disconnects specified global function from this signal.\n"
		"\t * \\tparam fn Pointer to the global function.\n"
		"\t */\n"
		"\ttemplate<void (*fn)()>\n"
		"\tvoid DisconnectHandler()\n"
		"\t{\n"
		"\t\tBaseSignal0<> bs;\n"
		"\t\tbs.Connect<fn>();\n"
		"\t\tsz = events.size();\n"
		"\t\tfor(i = 0; i<sz; i++)\n"
		"\t\t{\n"
		"\t\t\tif(events[i]==bs)\n"
		"\t\t\t{\n"
		"\t\t\t\tDisconnectHandler(i);\n"
		"\t\t\t\treturn;\n"
		"\t\t\t}\n"
		"\t\t}\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Erases specified event by its index.\n"
		"\t * \\param del Index of the base signal to delete.\n"
		"\t */\n"
		"\tvoid DisconnectHandler(unsigned int del)\n"
		"\t{\n"
		"\t\tif(del<events.size())\n"
		"\t\t{\n"
		"\t\t\tevents.erase(events.begin()+del);\n"
		"\t\t}\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Invokes this signal and calls all function connected to it.\n"
		"\t */\n"
		"\tvoid Invoke()\n"
		"\t{\n"
		"\t\tsz = events.size();\n"
		"\t\tfor(i = 0; i<sz; i++)\n"
		"\t\t{\n"
		"\t\t\tevents[i].Invoke();\n"
		"\t\t}\t\t\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Invokes this signal and calls all function connected to it.\n"
		"\t */\n"
		"\tvoid operator() ()\n"
		"\t{\n"
		"\t\tsz = events.size();\n"
		"\t\tfor(i = 0; i<sz; i++)\n"
		"\t\t{\n"
		"\t\t\tevents[i].Invoke();\n"
		"\t\t}\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Disconnects all base signals.\n"
		"\t */\n"
		"\tvoid DisconnectAll()\n"
		"\t{\n"
		"\t\tevents.clear();\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Disconnects specified slot from this signal.\n"
		"\t * \\param obj Pointer to the slot to disconnect.\n"
		"\t */\n"
		"\tvoid DisconnectSlot(void* obj)\n"
		"\t{\n"
		"\t\tfor(vector<BaseSignal0< > >::iterator i = events.begin(); i!=events.end(); i++)\n"
		"\t\t{\n"
		"\t\t\tif(i->s == obj)\n"
		"\t\t\t{\n"
		"\t\t\t\ti = events.erase(i);\n"
		"\t\t\t}\n"
		"\t\t\tif(i==events.end()) break;\n"
		"\t\t}\n"
		"\t}\n"
		"};");
}

void ReplaceString(string& code, const string& sfind, const stringstream& replaceto)
{
	string rp = replaceto.str();
	rp += "\0";
	size_t start = code.find(sfind.c_str(), 0);
	while(start != string::npos)
	{
		code.replace(start, sfind.length(), rp);
		start = code.find(sfind.c_str(), start);
	}
}

void WriteSignal(FILE* file, unsigned int paramcount)
{
	string code = "\n\n// for $no args\n"
		"/**\n"
		" * Used to invoke provided function from class.\n"
		" * \\tparam ret Return data type.\n"
		" * \\tparam cls Class name.\n"
		"$dthelp\n"
		" * \\tparam fn Function pointer.\n"
		" */\n"
		"template<class cls, class ret, $cls, ret (cls::*fn)($pliste)>\n"
		"class Invoker$no\n"
		"{\n"
		"public:\n"
		"\t/**\n"
		"\t * Invokes specified function.\n"
		"\t * \\param ptr Pointer to the class object used to invoke this function.\n"
		"\t$phelp\n"
		"\t * \\return Returns provided data type value.\n"
		"\t */\n"
		"\tstatic ret Invoke(void* ptr, $plist)\n"
		"\t{\n"
		"\t\treturn (static_cast<cls*>(ptr)->*fn)($pvalues);\n"
		"\t}\n"
		"};\n"
		"\n"
		"/**\n"
		" * Used to invoke global function.\n"
		" * \\tparam ret Return data type.\n"
		" * \\tparam fn Function pointer.\n"
		"$dthelp\n"
		" */\n"
		"template<class ret, $cls, ret (*fn)($pliste)>\n"
		"class Invoker$nog\n"
		"{\n"
		"public:\n"
		"\t/**\n"
		"\t * Invokes specified function with specified arguments.\n"
		"\t * \\param ptr Not used its just for signature matching purpose.\n"
		"\t$phelp\n"
		"\t * \\return Returns provided data type value.\n"
		"\t */\n"
		"\tstatic ret Invoke(void* ptr, $plist)\n"
		"\t{\n"
		"\t\treturn (*fn)($pvalues);\n"
		"\t}\n"
		"};\n"
		"\n"
		"/**\n"
		" * Signal to dynamically manage class/global function pointers.\n"
		" * \\tparam pt0 Data type of the first parameter.\n"
		" * \\tparam ret Return type of the functions which can be linked by this signal.\n"
		" */\n"
		"template<$cls, class ret = void>\n"
		"class BaseSignal$no\n"
		"{\n"
		"public:\n"
		"\ttypedef ret (*inv) (void*, $pliste); ///< Function type.\n"
		"\tinv f0; ///< Function pointer to invoke linked function.\n"
		"\tvoid* p; ///< Pointer to the class object used to invoke specified class function.\n"
		"\n"
		"\tBaseSlot* s; ///<< Pointer to the base slot connected to this signal.\n"
		"\tBaseSignal* parent; ///< Parent signal class object used for auto disconnection of slots.\n"
		"\n"
		"\t/**\n"
		"\t * Default constructor.\n"
		"\t */\n"
		"\tBaseSignal$no()\n"
		"\t{\n"
		"\t\tp = 0;\n"
		"\t\tf0 = 0;\n"
		"\t\ts = 0;\n"
		"\t\tparent = 0;\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Connects specified class and class function to this signal.\n"
		"\t * \\param ptr Pointer to the class object which is used to invoke specified function.\n"
		"\t * \\tparam cls Class name.\n"
		"\t * \\tparam fn Pointer to the class function.\n"
		"\t */\n"
		"\ttemplate<class cls, ret (cls::*fn)($pliste)>\n"
		"\tvoid Connect(cls* ptr)\n"
		"\t{\n"
		"\t\tf0 = &Invoker$no<cls, ret, $pliste, fn>::Invoke;\n"
		"\t\tp = ptr;\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Connects specified function with his signal.\n"
		"\t * \\tparam fn Pointer to the class function.\n"
		"\t */\n"
		"\ttemplate<ret (*fn)($pliste)>\n"
		"\tvoid Connect()\n"
		"\t{\n"
		"\t\tf0 = &Invoker$nog<ret, $pliste, fn>::Invoke;\n"
		"\t\tp = 0;\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Checks whether function pointer is null.\n"
		"\t * \\return true if function pointer is not null otherwise false.\n"
		"\t */\n"
		"\tbool Check()\n"
		"\t{\n"
		"\t\tif(f0==0) return false;\n"
		"\t\treturn true;\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Invokes function linked to this signal.\n"
		"\t$phelp\n"
		"\t * \\return Specified data type value.\n"
		"\t */\n"
		"\tret Invoke($plist)\n"
		"\t{\n"
		"\t\treturn f0(p, $pvalues);\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Invokes function linked to this signal.\n"
		"\t$phelp\n"
		"\t * \\return Specified data type value.\n"
		"\t */\n"
		"\tret operator() ($plist)\n"
		"\t{\n"
		"\t\treturn f0(p, $pvalues);\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Compares specified signal with this signal.\n"
		"\t * \\param val Pointer to the signal to compare with.\n"
		"\t * \\return true both are equal otherwise false.\n"
		"\t */\n"
		"\tbool operator==(BaseSignal$no<$pliste,ret>& val)\n"
		"\t{\n"
		"\t\tif(val.f0 == f0 && val.p == p) return true;\n"
		"\t\treturn false;\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Sets slot and adds parent signal to slot connections list.\n"
		"\t * \\param val Pointer to the slot to connect.\n"
		"\t */\n"
		"\tvoid SetSlot(BaseSlot* val)\n"
		"\t{\n"
		"\t\tthis->s = val;\n"
		"\t\tif(s != 0) s->Signals.push_back(parent);\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Copies specified signal to this one.\n"
		"\t * \\param val Pointer to the signal to copy.\n"
		"\t * \\return Reference to this signal.\n"
		"\t */\n"
		"\tBaseSignal$no& operator=(BaseSignal$no const& val)\n"
		"\t{\n"
		"\t\tthis->f0 = val.f0;\n"
		"\t\tthis->p = val.p;\n"
		"\t\tthis->parent = val.parent;\n"
		"\t\tSetSlot(val.s);\n"
		"\t\treturn *this;\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Copies specified signal to this one.\n"
		"\t * \\param val Pointer to the signal to copy.\n"
		"\t */\n"
		"\tBaseSignal$no(BaseSignal$no const& val)\n"
		"\t{\n"
		"\t\tthis->f0 = val.f0;\n"
		"\t\tthis->p = val.p;\n"
		"\t\tthis->parent = val.parent;\n"
		"\t\tSetSlot(val.s);\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Virtual destructor disconnects all signals from linked slot.\n"
		"\t */\n"
		"\tvirtual ~BaseSignal$no()\n"
		"\t{\n"
		"\t\tif(s!=0) s->DisconnectSignal(parent);\n"
		"\t}\n"
		"};\n"
		"\n"
		"/**\n"
		" * Signal used for signaling of events to the specified functions.\n"
		"$dthelp\n"
		" */\n"
		"template<$cls>\n"
		"class Signal$no : public BaseSignal\n"
		"{\n"
		"protected:\n"
		"\tvector<BaseSignal$no<$pliste> > events; ///< Signals list.\n"
		"\tunsigned int i; ///< Used for iteration.\n"
		"\tunsigned int sz; ///< Used for iteration.\n"
		"\n"
		"public:\n"
		"\t/**\n"
		"\t * Connects specified not derived(inherited) class and class function to this signal.\n"
		"\t * \\param obj Pointer to the class object which is used to invoke specified function.\n"
		"\t * \\return Number of connections to this signal - 1.\n"
		"\t * \\tparam cls Class name.\n"
		"\t * \\tparam fn Pointer to the class function.\n"
		"\t */\n"
		"\ttemplate<class cls, void (cls::*fn)($pliste)>\n"
		"\tunsigned int RegisterSingleHandler(cls* obj)\n"
		"\t{\n"
		"\t\tBaseSignal$no<$pliste> bs;\n"
		"\t\tbs.template Connect<cls, fn>(obj);\n"
		"\t\tevents.push_back(bs);\n"
		"\t\treturn events.size() - 1;\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Connects specified derived(inherited) class and class function to this signal.\n"
		"\t * \\param obj Pointer to the class object which is used to invoke specified function.\n"
		"\t * \\return Number of connections to this signal - 1.\n"
		"\t * \\tparam cls Class name.\n"
		"\t * \\tparam fn Pointer to the class function.\n"
		"\t */\n"
		"\ttemplate<class cls, void (cls::*fn)($pliste)>\n"
		"\tunsigned int RegisterHandler(cls* obj)\n"
		"\t{\n"
		"\t\tBaseSignal$no<$pliste> bs;\n"
		"\t\tbs.template Connect<cls, fn>(obj);\n"
		"\t\tbs.parent = this;\n"
		"\t\tbs.SetSlot(dynamic_cast<BaseSlot*>(obj));\n"
		"\t\tevents.push_back(bs);\n"
		"\t\treturn events.size() - 1;\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Connects specified global function to this signal.\n"
		"\t * \\return Number of connections to this signal - 1.\n"
		"\t * \\tparam fn Pointer to the global function.\n"
		"\t */\n"
		"\ttemplate<void (*fn)($pliste)>\n"
		"\tunsigned int RegisterHandler()\n"
		"\t{\n"
		"\t\tBaseSignal$no<$pliste> bs;\n"
		"\t\tbs.template Connect<fn>();\n"
		"\t\tevents.push_back(bs);\n"
		"\t\treturn events.size() - 1;\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Erases specified event by its index.\n"
		"\t * \\param del Index of the base signal to delete.\n"
		"\t */\n"
		"\tvoid DisconnectHandler(unsigned int del)\n"
		"\t{\n"
		"\t\tif(del<events.size())\n"
		"\t\tevents.erase(events.begin()+del);\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Disconnects specified class and class function from this signal.\n"
		"\t * \\param obj Pointer to the class object which is to be disconnected.\n"
		"\t * \\tparam cls Class name.\n"
		"\t * \\tparam fn Pointer to the class function.\n"
		"\t */\n"
		"\ttemplate<class cls, void (cls::*fn)($pliste)>\n"
		"\tvoid DisconnectHandler(cls* obj)\n"
		"\t{\n"
		"\t\tBaseSignal$no<$pliste> bs;\n"
		"\t\tbs.template Connect<cls, fn>(obj);\n"
		"\t\tsz = events.size();\n"
		"\t\tfor(i = 0; i<sz; i++)\n"
		"\t\t{\n"
		"\t\t\tif(events[i]==bs)\n"
		"\t\t\t{\n"
		"\t\t\t\tDisconnectHandler(i);\n"
		"\t\t\t\treturn;\n"
		"\t\t\t}\n"
		"\t\t}\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Disconnects specified global function from this signal.\n"
		"\t * \\tparam fn Pointer to the global function.\n"
		"\t */\n"
		"\ttemplate<void (*fn)($pliste)>\n"
		"\tvoid DisconnectHandler()\n"
		"\t{\n"
		"\t\tBaseSignal$no<$pliste> bs;\n"
		"\t\tbs.template Connect<fn>();\n"
		"\t\tsz = events.size();\n"
		"\t\tfor(i = 0; i<sz; i++)\n"
		"\t\t{\n"
		"\t\t\tif(events[i]==bs)\n"
		"\t\t\t{\n"
		"\t\t\t\tDisconnectHandler(i);\n"
		"\t\t\t\treturn;\n"
		"\t\t\t}\n"
		"\t\t}\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Invokes this signal and calls all function connected to it.\n"
		"\t$phelp\n"
		"\t */\n"
		"\tvoid Invoke($plist)\n"
		"\t{\n"
		"\t\tsz = events.size();\n"
		"\t\tfor(i = 0; i<sz; i++)\n"
		"\t\t{\n"
		"\t\t\tevents[i].Invoke($pvalues);\n"
		"\t\t}\t\t\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Invokes this signal and calls all function connected to it.\n"
		"\t$phelp\n"
		"\t */\n"
		"\tvoid operator() ($plist)\n"
		"\t{\n"
		"\t\tsz = events.size();\n"
		"\t\tfor(i = 0; i<sz; i++)\n"
		"\t\t{\n"
		"\t\t\tevents[i].Invoke($pvalues);\n"
		"\t\t}\n"
		"\t}\n"
		"\n"
		"\t/**\n"
		"\t * Disconnects all base signals.\n"
		"\t */\n"
		"\tvoid DisconnectAll()\n"
		"\t{\n"
		"\t\tevents.clear();\n"
		"\t}\n"
		"\n"
		"\n"
		"\t/**\n"
		"\t * Disconnects specified slot from this signal.\n"
		"\t * \\param obj Pointer to the slot to disconnect.\n"
		"\t */\n"
		"\tvoid DisconnectSlot(void* obj)\n"
		"\t{\n"
		"\t\tfor(typename vector<BaseSignal$no<$pliste> >::iterator i = events.begin(); i!=events.end(); i++)\n"
		"\t\t{\n"
		"\t\t\tif(i->s == obj)\n"
		"\t\t\t{\n"
		"\t\t\t\ti = events.erase(i);\n"
		"\t\t\t}\n"
		"\t\t\tif(i==events.end()) break;\n"
		"\t\t}\n"
		"\t}\n"
		"};";

		/**
		$no = 1
		$dthelp = * \tparam pt0 Data type of the first parameter.
		$cls = class pt0
		$phelp =	* \param p0 Value of the first parameter.
		$pliste = pt0
		$plist = pt0 p0
		$pvalues = p0
		*/

		stringstream no;
		stringstream dthelp;
		stringstream cls;
		stringstream phelp;
		stringstream pliste;
		stringstream plist;
		stringstream pvalues;

		no << paramcount;

		for(unsigned int i = 0; i<paramcount; i++)
		{
			if(i!=0)
			{
				dthelp << "\n";
				cls << ", ";
				phelp << "\n\t";
				pliste << ", ";
				plist << ", ";
				pvalues << ", ";
			}
			
			dthelp << " * \\tparam pt" << i;
			dthelp << " Data type of the parameter " << (i+1) << ".";
			
			cls << "class pt" << i;
			
			phelp << " * \\param p" << i;
			phelp << " Value of the parameter " << (i+1) << ".";

			pliste << "pt" << i;

			plist << "pt" << i;
			plist << " p" << i;

			pvalues << "p" << i;
		}

		ReplaceString(code, "$no", no);
		ReplaceString(code, "$dthelp", dthelp);
		ReplaceString(code, "$cls", cls);
		ReplaceString(code, "$phelp", phelp);
		ReplaceString(code, "$pliste", pliste);
		ReplaceString(code, "$plist", plist);
		ReplaceString(code, "$pvalues", pvalues);

		fprintf(file, code.c_str());
		return;
}

int _tmain(int argc, _TCHAR* argv[])
{
	char filename[256];
	unsigned int nfcount = 0;

	printf("Enter filename/path : ");
	scanf("%s", filename);
	printf("Enter number of parameters required : ");
	scanf("%d", &nfcount);

	FILE* file = fopen(filename, "w");
	if(file==0)
	{
		printf("Unable to open file for writting ...\n");
		return 0;
	}
	WriteSignal0Base(file);
	for(unsigned int i = 0; i<nfcount; i++)
	{
		WriteSignal(file, i+1);
	}
	fclose(file);

	printf("Successfully created header file ...\n");
	return 0;
}

